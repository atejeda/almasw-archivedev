logstash         | [2019-03-13T03:24:58,827][WARN ][logstash.filters.xml     ] Error parsing xml with XmlSimple {:source=>"message", :value=>"<Debug TimeStamp=\"2019-03-05T12:34:36.152\" File=\"AutomaticArrayOperationalState.java\"  Line=\"766\" Routine=\"getObsScript\" Host=\"alma-build.aoc.nrao.edu\" Process=\"CO
NTROL/ACC/javaContainer\" SourceObject=\"CONTROL/Array11-BLC\" Thread=\"CONTROL/Array11-BLC-1\" LogId=\"70932\"><![CDATA[Using the standard script:\n#! /usr/bin/env python\n# ALMA - Atacama Large Millimeter Array\n# (c) Associated Universities Inc., 2009 - 2014\n# \n# This library is free software; you can redistri
bute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# \n# This library is distributed in the hope that i1t will be useful,\n# but WITHOUT ANY WARRANTY; with
out even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n# \n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc.,
 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA\n\n#************************************************************************\n#   NAME StandardInterferometry.py\n# \n#   SYNOPSIS This script is intended to meet the needs of single or multi-target\n#       observations which have a common spectral configurat
ion for all\n#       science targets and a shared primary phase calibrator.  \n# \n#------------------------------------------------------------------------\n\n#\n# forcing global imports is due to an OSS problem\n#\nglobal CCL\nfrom CCL.Global import getArray\nimport CCL.APDMSchedBlock\nfrom CCL.ObservingModeBase 
import SBOutOfTime\nfrom PyDataModelEnumeration import PyCalibrationDevice\nglobal Observation\nimport Observation.SchedulingBlock\nfrom Observation.SBExecutionMode import SBExecutionMode, SBExecutionError\nfrom Observation.Global import simulatedArray, addClassToMode\nfrom Observation.PointingCalTarget import Poin
tingCalTarget\nfrom Observation.ScanList import ScanList\nfrom Observation.SBExecState import SBExecState\nimport Observation.SSRLogger\nglobal TelCalParameters\nimport TelCalParameters\n\n\n# Ugly hack to get nice logging when we're not written as a class\nclass StandardInterferometry(Observation.SSRLogger.SSRLogg
er):\n    def __init__(self):\n        Observation.SSRLogger.SSRLogger.__init__(self, self.__class__.__name__)\nlogger = StandardInterferometry()\n\nsb = Observation.SchedulingBlock.SchedulingBlock()\nlogger.logInfo('Running %s scheduling block' % sb._controlSB.name)\n\n# TODO: add type-check for expert parameters 
: PRTSPR-24831\n\n# Get expert parameters as needed here\nelLimit         = float(sb.getExpertParameter('ElLimit', default=20.))\nmaxPointingSeparation = float(sb.getExpertParameter('MaxPointingSeparation', default=25.))\nsourceCycle     = float(sb.getExpertParameter('SourceCycleTime', default=0))\nuseScanSequence 
= bool(int(sb.getExpertParameter('useScanSequence', default=True)))\nuseDualMode     = bool(int(sb.getExpertParameter('useDualMode', default=True)))\nfastSWEnabled   = bool(int(sb.getExpertParameter('FastSWEnabled', default=False)))\n# Below are parameters for DiffGainCalTarget\ndgcExtCycle   = float(sb.getExpertPa
rameter('dgcExtCycle', default=7200.))\ndgcIntCycle   = float(sb.getExpertParameter('dgcIntCycle', default=60.))\ndgcRefIntTime = float(sb.getExpertParameter('dgcRefIntTime', default=240.))\ndgcSciIntTime = float(sb.getExpertParameter('dgcSciIntTime', default=180.))\ndgcSourceName = str(sb.getExpertParameter('dgcSo
urceName', default=''))\ndgcSourceRa   = str(sb.getExpertParameter('dgcSourceRa', default=''))  # hh:mm:ss.sss\ndgcSourceDec  = str(sb.getExpertParameter('dgcSourceDec', default='')) # dd.mm.ss.sss\ndgcPostpone   = float(sb.getExpertParameter('dgcPostpone', default=0.))\nuseDGC        = int(sb.getExpertParameter('u
seDGC', default=0))\nuseHarmonicB2B= bool(int(sb.getExpertParameter('useHarmonicB2B', default=0)))\nharmonicB2BPreferredBand= int(sb.getExpertParameter('harmonicB2BPreferredBand', default=0))\nif harmonicB2BPreferredBand <= 0:\n    harmonicB2BPreferredBand = None\n# A parameter for overrding WVR correction on/off/b
oth. (\"\", \"off\", \"on\", \"both\")\nwvrProduct = str(sb.getExpertParameter(\"wvrProduct\", default=''))\n# logger.logInfo('%s' % sb.getExpertParameters())\n\nlogger.logInfo(\"useDualMode value %s\" % useDualMode)\nlogger.logInfo(\"useScanSequence value %s\" % useScanSequence)\nlogger.logInfo('fastSWEnabled=%s' 
% fastSWEnabled)\nlogger.logInfo('wvrProduct=%s' % wvrProduct)\nlogger.logInfo(\"useHarmonicB2B = %s, harmonicB2BPreferredBand = %s\" % (str(useHarmonicB2B), str(harmonicB2BPreferredBand)))\n\nB_max = 450.0 # length, in meters, of the longest baseline in the array to be executed.  Could either\n              # get 
this from the resolution requirement or from the scheduler with the configuration\nif sourceCycle <= 0:\n    sourceCycle = 12.0/(B_max*7.29e-5)\nlogger.logInfo('Source Cycle Time: %f s' % sourceCycle)\nsessionControl = int(sb.getExpertParameter('SessionControl', default=0))\nlogger.logInfo('Session control %d' % se
ssionControl)\nlogger.logInfo('Simulated Array %s' % simulatedArray())\n\n# Get reference to the array and start the exec block\narray = getArray()\n\narray.beginExecution()\n\n# None means OK. If an error occurs the status is replaced, in the catch block, by the exception.\nstatus = None\nobsmode = None\ntry:\n   
 obsmode = array.getInterferometryObservingMode()\n\n    # Add the SB execution methods\n    addClassToMode(obsmode, SBExecutionMode)\n    logger.logInfo(\"ASDM UID = %s\" % (obsmode.getExecBlockUID()))\n\n    corrType = array.getCorrelatorType()\n    enableWVRCorrection = False\n    if str(corrType) == \"BL\":\n  
      enableWVRCorrection = True\n    arrayName = array._arrayName.replace(\"CONTROL/\", \"\")\n    logger.logInfo(\"Setting TelCal parameters for array %s: ontheflyWVRcorrection=%s spectrum=True useMiddleElevation=True\" % (arrayName, enableWVRCorrection))\n    if not simulatedArray():\n        tcParameters = TelC
alParameters.TelCalParameters(arrayName)\n        tcParameters.setCalibParameter('ontheflyWVRcorrection', enableWVRCorrection)\n        # spectrum is to enable channel-by-channel bandpass result. Also binningFactor can be specified if desired.\n        tcParameters.setCalibParameter('spectrum', True)\n        tcPar
ameters.setCalibParameter('useMiddleElevation', True)\n\n    # Session memory\n    sbe = SBExecState(array, sb)\n    isFirstExecutionInSession = True\n    if sessionControl:\n        sbe.startSession()\n        isFirstExecutionInSession = sbe.isFirstTime()\n        logger.logInfo(\"isFirstExecutionInSession=%s\" % 
(isFirstExecutionInSession))\n    obsmode.addSBExecState(sbe)\n\n    # Just start on the sky, to be sure. Should be in the mode defaults.\n    obsmode.setCalibrationDevice(PyCalibrationDevice.NONE)\n\n    # Set observing mode restrictions\n    logger.logInfo(\"Setting elevation limit to %f degrees\" % elLimit)\n   
 obsmode.setElevationLimit('%f deg' % elLimit)\n\n    endTime = sb.getMaximumExecutionTime()\n    logger.logInfo(\"Setting maximum execution time to %s seconds\" % (endTime))\n    obsmode.setMaximumSchedBlockTime(endTime)\n\n    logger.logInfo(\"Setting max. pointing separation  to %f degrees\" % maxPointingSeparat
ion)\n    PointingCalTarget.setMaximumSeparation('%f deg' % maxPointingSeparation )\n\n    groupList = sb.getGroupList()\n    # # Check the visibility of science targets in all groups.\n    # for iGroup, group in enumerate(groupList):\n    #     if obsmode.checkScienceTargetVisibility(group):\n    #         continu
e\n    #     raise SBExecutionError(\"No visible science target [Group%d]\" % (iGroup + 1))\n\n    for iGroup, group in enumerate(groupList):\n        # Perform doppler correction for spectral specs associated with this group.\n        sb.adjustDopplerByGroup(obsmode, group)\n\n    # ICT-10545 Cycle-5 fudge to use 
OT auto-generated 90 deg switching SpectralSpecs\n    Observation.SSRTuning.fiddle90degSpectralSpecs(sb, logger, obsmode)\n\n    # ICT-9118\n    if useHarmonicB2B:\n        Observation.SSRTuning.overridePhaseCalSpectralSpecsWithHarmonicB2B(sb, array, logger, obsmode, harmonicB2BPreferredBand)\n\n    # In bands 8 an
d lower it makes most practical sense to point in-band if we\n    # have weather for science in that band. The practical difficulties of\n    # maintaining good TMCDB band offsets trump the S/N arguments, which are not\n    # that great anyway as people forget the positive effect of decreasing beam\n    # width wit
h increasing frequency.\n    Observation.SSRTuning.overridePointingSpectralSpecs(sb, array, logger, obsmode)\n\n    for iGroup, group in enumerate(groupList):\n        # ICT-7809: Estimate source flux and register to FieldSource.\n        group.setSourceFluxForNonQuerySources()\n        # Then, resolve queries.\n  
      group.prepareTargets(minEl=elLimit,\n                             isFirstExecutionInSession=isFirstExecutionInSession,\n                             obsmode=obsmode)\n        sb.updateTargetList()\n        # And, create associated ATM targets (spectral specs shall be in TOPO)\n        group.createAtmCalTarget
s(isSingleDish=False)\n\n        # SBR targets are omitted from normal science SB executions, but\n        # if it is requested to revert, here is the place to add SBR targets.\n        ### group.createSBRatioCalTargets()\n    sb.pruneSharableATMTargets()\n    sb.updateTargetList()\n\n    # Try to make sure there i
s at least two number of unique calibrator\n    # sources observed in science setup.\n    sb.checkForDuplicateCalSources()\n\n    # If amp cal is missing, attach CALIBRATE_FLUX intent to bandpass.\n    sb.tweakForMissingIntents()\n\n    # Just for in case...\n    for target in sb.getTargetList():\n        dopRef = 
str(target.getSpectralSpec().FrequencySetup.dopplerReference)\n        logger.logInfo(\"dopRef=%s getUseReferencePosition=%s %s\" % (dopRef, target.getUseReferencePosition(), target))\n        import Observation.AtmCalTarget\n        if isinstance(target, Observation.AtmCalTarget.AtmCalTarget):\n            assert(
target.getUseReferencePosition() == True)\n        else:\n            target.setUseReferencePosition(False)\n\n    if wvrProduct != \"\":\n        # Switch between online-WVR on/off/both.\n        sb.setWVRProduct(wvrProduct)\n\n    # Assign an ID to each target.\n    sb.setTargetsId()\n\n    # If \"AddToCleanup\" 
target-level expert parameter is defined, add the\n    # target to cleanup list.\n    for group in groupList:\n        group.addTargetsToCleanUpIfRequired(obsmode)\n\n    if sessionControl:\n        # Recycle Field Sources\n        obsmode.sbe.recycleFieldSources()\n        # Recycle attenuator settings\n        # 
Mark _ifSkyAttenSet to re-use previous attenuator optimizations.\n        # This relies on the fact that attenuator setting name is identical as\n        # spectral spec name.\n        obsmode.sbe.recycleAttenSettings()\n        obsmode.sbe.restoreScienceTargetParameters()\n\n    # construct DiffGainCalTarget, if needed\n    if useDGC:\n        kwargs = dict(dgcExtCycle=dgcExtCycle,\n                      dgcIntCycle=dgcIntCycle,\n                      dgcRefIntTime=dgcRefIntTime,\n                      dgcSciIntTime=dgcSciIntTime,\n                      dgcSourceName=dgcSourceName,\n                      dgcSourceRa=dgcSour
ceRa,\n                      dgcSourceDec=dgcSourceDec,\n                      dgcPostpone=dgcPostpone)\n        isB2B = group.isBandToBand()\n        logger.logInfo('isB2B = %s' % (isB2B))\n        # Both B2B and BW switching observations can construct DGC target\n        # instance in a same way.\n        diffGainCalTarget = group.constructDiffGainCalTargetForB2B(obsmode,\n                                                                   **kwargs)\n        diffGainCalTarget.setOnlineProcessing(False)\n\n    # Tweak reference position of targets, if they are specified in relative\n    # horizontal frame.\n    for group in sb.getGroupList():\n        from Observation.ScienceTarget import ScienceTarget\n        from Observation.AtmCalTarget import AtmCalTarget\n        for target in group.getTargetList():\n            if isinstance(target, ScienceTarget):\n                continue\n            for assocTarget in target.getAssociatedCalTarget():\n                if not isinstance(assocTarget, AtmCalTarget):\n                    continue\n                assocTarget.tweakReferenceOffset(verbose=True,\n                                                 saveOffsetToFS=True)\n\n    # SCIREQ-290: remove ampcal, if it shares same source with bandpass cal\n    for group in groupList:\n        group.removeSharableTargets()\n\n    # ICT-13002: Check the visibility of science targets in group2.\n    # Naively assume that if group2 targets are ready, then targets in\n    # the subsequent groups are also ready.\n    estimatedGroup1Duration = sb.estimateGroup1Duration()\n    for group in groupList[1:2]:\n        if obsmode.checkScienceTargetVisibility(group,\n                                                inTime=estimatedGroup1Duration):\n            continue\n        raise SBExecutionError(\"No visible science target [Group%d]\" % (iGroup + 1))\n\n    # The first group is for SB calibrators, we don't expect any science target.\n    group = groupList[0]\n    groupNumber = group.groupIndex\n    logger.logInfo(\"Start Observing Group %d (Calibrations)\" % groupNumber)\n    scanList = ScanList() if useScanSequence else None\n    # Optionally force-enable dual mode on SpectralSpecs.\n    if useDualMode :\n        for target in sb.getTargetList() :\n            ss = target._spectralSpec\n            logger.logInfo(\"Dual mode addition: evaluating SpectralSpec named '%s'\" % str(ss.name))\n            if not hasattr(ss,'SquareLawSetup') or ss.SquareLawSetup is None:\n                logger.logInfo(\"Dual
 mode addition: adding SquareLawSetup to SpectralSpec named '%s'\" % str(ss.name))\n                ss.SquareLawSetup = CCL.APDMSchedBlock.SquareLawSetup()\n                ss.SquareLawSetup.integrationDuration.set(0.016)\n    # ICT-5552: For Cycle-3 OT will still give us short subscans, but we'll combine them when we can\n    for target in sb.getTargetList() :\n        logger.logInfo(\"setting target.coalesceSubscans = True on '%s' it was %s\" % (str(target), str(target.coalesceSubscans)))\n        target.coalesceSubscans = True\n    # From Cycle-6 disable online WVR if it was enabled, e.g. for Cycle-5 carry-over\n    for target in sb.getTargetList() :\n        ss = target._spectralSpec\n        logger.logInfo(\"APC check: evaluating SpectralSpec named '%s'\" % str(ss.name))\n        if ss.hasBLCorrelatorConfiguration():\n            logger.logInfo(\"APC check: setting aPCDataSets = AP_UNCORRECTED for BL configuration in '%s'\" % str(ss.name))\n            ss.BLCorrelatorConfiguration.aPCDataSets = u'AP_UNCORRECTED'\n\n    obsmode.executeCalTargetList(group.getFocusCalTargetList())\n\n    # Polarization section needs to be cleanup a bit.\n    obsmode.executeCalTargetList(group.getPolarizationCalTargetList(),\n                                 deferToCleanupList=True, scanList=scanList)\n    if useScanSequence:\n        scanList.execute(obsmode)\n    if len(group.getPolarizationCalTargetList()) > 0:\n        obsmode.addTargetToCleanupList(group.getPolarizationCalTargetList()[0])\n\n    # enable online bandpass\n    for target in sb.getBandpassCalTargetList():\n        logger.logInfo(\"Online bandpass: enable online processing on target '%s'\" % str(target))\n        target.setOnlineProcessing(True)\n\n    import Observation.CalParameterOptimization\n    cParamOpt = Observation.CalParameterOptimization.CalParameterOptimization()\n    for target in group.getBandpassCalTargetList():\n        cParamOpt.optimizeDuration(target, \"bandpass\", obsmode=obsmode)\n\n    obsmode.executeCalTargetListSpec(group.getBandpassCalTargetList(),\n                                     deferToCleanupList=True,\n                                     scanList=scanList)\n    if useScanSequence:\n
   scanList.execute(obsmode)\n\n    obsmode.executeCalTargetList(group.getDelayCalTargetList(),\n                                 scanList=scanList)\n    if useScanSequence:\n        scanList.execute(obsmode)\n\n    obsmode.executeCalTargetList(group.getAmplitudeCalTargetList(),\n                                 de
ferToCleanupList=True, scanList=scanList)\n    if useScanSequence:\n        scanList.execute(obsmode)\n\n    values = (obsmode.getElapsedTime(), estimatedGroup1Duration)\n    msg = \"Group1 End: Elapsed=%6.1f [sec] Estimated=%6.1f [sec]\" % values\n    logger.logInfo(msg)\n\n    # Now the rest of the groups should
contain science targets.\n    for group in groupList[1:]:\n        # TODO: For Cycle5?: allow self-calibration\n\n        for target in group.getPhaseCalTargetList():\n            cParamOpt.optimizeDuration(target, \"phase\", obsmode=obsmode)\n\n        groupNumber = group.groupIndex\n        # The primary phase ca
librator is assumed to be the one with the\n        # shortest cycle time in the group.  This effectivly sets the scan\n        # duration.\n        primaryPhaseCal = obsmode.getPrimaryPhaseCal(group)\n        if primaryPhaseCal is None:\n            logger.logError(\"No phase calibrator available in Observing Grou
p %s\" % groupNumber)\n            raise SBExecutionError(\"There is no available phase calibrator, at this moment.\")\n        else:\n            logger.logInfo(\"Selected %s as Primary phase calibrator\" % primaryPhaseCal)\n\n        # ICT-7246: If phase cycle time is less than 150 seconds, enable fast SW mode.\n
        fastSWEnabled = group.isFastSWRequired()\n        logger.logInfo(\"[Group%d] fastSWEnabled=%s\" % (groupNumber, fastSWEnabled))\n        logger.logInfo(\"Start Observing Group %d (Science)\" % groupNumber)\n\n        # A group is defined to be complete when all science targets within\n        # the group ar
e complete (or unobservable)\n        obsmode.assignSubcycleTime(group.getScienceTargetList(), sourceCycle)\n        while not group.isComplete(obsmode):\n            # Just for reporting the achieved integration times\n            sb.checkRemainingIntegrationTimes()\n\n            outerCycleTargets = list(group.ge
tFocusCalTargetList()) + \\\n                                list(group.getAmplitudeCalTargetList()) + \\\n                                list(group.getPolarizationCalTargetList()) + \\\n                                list(group.getBandpassCalTargetList()) + \\\n                                list(group.getDelay
CalTargetList()) + \\\n                                list(group.getCheckSourceCalTargetList())\n            if useDGC:\n                outerCycleTargets.append(diffGainCalTarget)\n\n            secondaryPhaseCals = list(group.getPhaseCalTargetList())\n            secondaryPhaseCals.remove(primaryPhaseCal)\n\n
         # If one of these target are executed, it would be nice\n            # to call primary.overwriteNextExecutionTime(value=0.),\n            # since in that case, we can make that duration of\n            # each science target execution more uniform.\n\n            obsmode.executeCalTargetList(group.getFocusC
alTargetList(),\n                                         scanList=scanList)\n            if useScanSequence:\n                scanList.execute(obsmode)\n\n            obsmode.executeCalTargetList(group.getPolarizationCalTargetList(),\n                                         scanList=scanList)\n            if useS
canSequence:\n                scanList.execute(obsmode)\n\n            obsmode.executeCalTargetList(group.getBandpassCalTargetList(),\n                                         scanList=scanList)\n            if useScanSequence:\n                scanList.execute(obsmode)\n\n            obsmode.executeCalTargetList(g
roup.getAmplitudeCalTargetList(),\n                                         scanList=scanList)\n            if useScanSequence:\n                scanList.execute(obsmode)\n\n            if useDGC:\n                # DiffGainCal\n                # For B2B observations, it is desired to execute DGC just before the pr
imary phase cal execution.\n                isExecuted = diffGainCalTarget.executeIfNeeded(obsmode, scanList=scanList)\n                if isExecuted:\n                    # Force execution of next primary phase calibrator.\n                    primaryPhaseCal.overwriteNextExecutionTime(value=0.)\n\n            obs
mode.executeCalTargetList(group.getPhaseCalTargetList(), deferToCleanupList=True,\n                                         minimumInCleanupList=len(group.getPhaseCalTargetList()),\n                                         scanList=scanList)\n            if not fastSWEnabled and useScanSequence:\n                sc
anList.execute(obsmode)\n\n            # Test Source execution.\n            # It is executed at every outer loop execution on the target.\n            obsmode.executeCalTargetList(group.getDelayCalTargetList() +\n                                         group.getCheckSourceCalTargetList(), scanList=scanList)\n
        if not fastSWEnabled and useScanSequence:\n                scanList.execute(obsmode)\n\n            while not group.isComplete(obsmode):\n                # Inner-cycle: if scan-sequence is enabled, try to sequence as many as possible science and phase scans.\n                # execute science targets until
either a calibration is needed\n                obsmode.executeScienceTargetList(group, outerCycleTargets + [primaryPhaseCal], scanList=scanList)\n                if not fastSWEnabled and useScanSequence:\n                    scanList.execute(obsmode)\n                # then, phase-cal\n                primaryPhase
Cal.execute(obsmode, scanList=scanList)\n\n                if not fastSWEnabled and useScanSequence:\n                    scanList.execute(obsmode)\n\n                # Check whether the primary phase calibrator will be above the\n                # elevation limit for the next cycle.\n                # ICT-6300: If
 cycle time is extremely long, cap the duration\n                # for visibility check by the remaining science target\n                # integration time.\n                duration = min(primaryPhaseCal.getCycleTime(),\n                               group.getRemainingIntegrationTime() + primaryPhaseCal.getIntegr
ationTime())\n                if not primaryPhaseCal.isObservable(obsmode, duration=duration, scanList=scanList):\n                    primaryPhaseCal = obsmode.getPrimaryPhaseCal(group, primaryPhaseCal)\n                    if primaryPhaseCal is None:\n                        raise Exception('There is no available
 phase calibrator in group%d at this moment, and thus stopping this SB execution. If SB does contain at least one valid phase calibrator in group%d, then it is likely that all of them are (judged to be) below the elevation limit.' % (groupNumber, groupNumber))\n\n                if not fastSWEnabled:\n
       # If fast-sw disabled, do not try to sequence phase and science targets\n                    break\n                if useScanSequence and scanList.getCurrentCompletionTime() > 600:\n                    break\n\n                # loop-end condition. (If outer-cycle targets need execution, get out of inner lo
op)\n                currentElapsedTime = obsmode.sbe.getElapsedTime() if sessionControl else obsmode.getElapsedTime()\n                if useScanSequence:\n                    currentElapsedTime += scanList.getCurrentCompletionTime()\n                nextReqTimes = [target.getNextRequiredTime() for target in outer
CycleTargets + secondaryPhaseCals]\n                if len(nextReqTimes) > 0 and min(nextReqTimes) <= currentElapsedTime:\n                    break\n\n            # Exexcute sequence of science and primary phase cal scans\n            if useScanSequence:\n                scanList.execute(obsmode)\n\n        # Grou
p is complete: remove the primaryPhaseCal from cleanup:\n        logger.logInfo(\"Observing Group %s is completed.\" % groupNumber)\n        obsmode.removeTargetFromCleanupList(primaryPhaseCal)\n\n        # ICT-8368: 'cleanup' execution for secondary phase calibrators.\n        for target in secondaryPhaseCals:\n
          target.execute(obsmode)\n            obsmode.removeTargetFromCleanupList(target)\n\n    # All groups are complete: execute the cleanup (e.g. bandpass or amplitude cals)\n    logger.logInfo(\"All groups are completed.\")\n    logger.logInfo(\"Executing cleanup list.\")\n    obsmode.executeCleanupList(scanL
ist=scanList)\n    if useScanSequence:\n        scanList.execute(obsmode)\nexcept SBOutOfTime:\n    logger.logWarning(\"Running short of time, forcing cleanup!\")\n    groupNumber = group.groupIndex\n    if sessionControl and groupNumber > 0 and hasattr(group, \"_subcycleIndex\"):\n        currentIndex = sbe.getSci
enceTargetIndex(groupNumber)\n        if currentIndex == group._subcycleIndex:\n            group._subcycleIndex = (group._subcycleIndex + 1) % len(group.getScienceTargetList())\n        sbe.saveScienceTargetIndex(groupNumber, group._subcycleIndex)\n    if useScanSequence:\n        scanList.execute(obsmode)\n    lo
gger.logInfo(\"Executing cleanup list.\")\n    obsmode._maximumTime = None", :exception=>#<REXML::ParseException: Declarations can only occur in the doctype declaration.
logstash         | Line: 500
logstash         | Position: 24920
logstash         | Last 80 unconsumed characters:
logstash         | <![CDATA[Using the standard script: #! /usr/bin/env python # ALMA - Atacama Large>, :backtrace=>["uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/rexml/parsers/baseparser.rb:362:in `pull_event'", "uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/rexml/parsers/baseparser.rb:185:in `pull'"
, "uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/rexml/parsers/treeparser.rb:23:in `parse'", "uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/rexml/document.rb:288:in `build'", "uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/rexml/document.rb:45:in `initialize'", "/usr/share/logstash/vendor/bundle
/jruby/2.3.0/gems/xml-simple-1.1.5/lib/xmlsimple.rb:971:in `parse'", "/usr/share/logstash/vendor/bundle/jruby/2.3.0/gems/xml-simple-1.1.5/lib/xmlsimple.rb:164:in `xml_in'", "/usr/share/logstash/vendor/bundle/jruby/2.3.0/gems/xml-simple-1.1.5/lib/xmlsimple.rb:203:in `xml_in'", "/usr/share/logstash/vendor/bundle/jrub
y/2.3.0/gems/logstash-filter-xml-4.0.5/lib/logstash/filters/xml.rb:187:in `filter'", "/usr/share/logstash/logstash-core/lib/logstash/filters/base.rb:145:in `do_filter'", "/usr/share/logstash/logstash-core/lib/logstash/filters/base.rb:164:in `block in multi_filter'", "org/jruby/RubyArray.java:1734:in `each'", "/usr/
share/logstash/logstash-core/lib/logstash/filters/base.rb:161:in `multi_filter'", "/usr/share/logstash/logstash-core/lib/logstash/filter_delegator.rb:47:in `multi_filter'", "(eval):990:in `block in filter_func'", "/usr/share/logstash/logstash-core/lib/logstash/pipeline.rb:447:in `filter_batch'", "/usr/share/logstas
h/logstash-core/lib/logstash/pipeline.rb:426:in `worker_loop'", "/usr/share/logstash/logstash-core/lib/logstash/pipeline.rb:385:in `block in start_workers'"]}
